<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8"/>
        <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
        <title>Star Fields</title>

        <script src="https://cdn.tailwindcss.com"></script>

        <style>
            #viaje {
                image-rendering: crisp-edges;
                image-rendering: pixelated;
            }
        </style>
    </head>
    <body class="m-0 h-screen bg-black overflow-hidden">

    <canvas id="viaje" class="block w-full h-full"></canvas>

    <div id="audio-controls" class="fixed left-2 top-16 z-10 text-white font-mono flex items-center gap-2">
        <button id="music-toggle" class="px-4 py-1 bg-blue-600 hover:bg-blue-700 rounded">Play</button>
        <input id="music-volume" type="range" min="0" max="1" step="0.01" value="0.5" class="w-40">
    </div>

    <script>
        const CONFIG = {
            journeySeconds: 285,
            camera: {focal: 600},
            starfield: {
                stopNearAt: 90,
                numFar: 100,
                numNear: 200,
                farSpeedRange: [0.001, 0.0025],
                nearSpeedRange: [1.0, 5.0],
                speedScale: 0.05,
                focalLength: 128
            },
            sun: {
                radius: 0.0008,
                color: "#ffcc00",
                keyframes: [
                    {second: 0, pos: {x: 0, y: 0, z: 2000}},
                    {second: 100, pos: {x: 0, y: 0, z: 1000}},
                    {second: 110},
                    {second: 120, pos: {x: -0.012, y: 0, z: 1.09}}
                ]
            },
            mars: {
                radius: 0.0008 / 2,
                color: "#b75741",
                keyframes: [
                    {second: 0, pos: {x: 0, y: 0, z: 2000}},
                    {second: 105, pos: {x: 0, y: 0, z: 1000}},
                    {second: 118, pos: {x: -0.05, y: 0, z: 2}}
                ]
            },
            jupiter: {
                radius: 0.0008,
                color: "#f3e8a3",
                keyframes: [
                    {second: 0, pos: {x: 0, y: 0, z: 2000}},
                    {second: 105, pos: {x: 0, y: 0, z: 1000}},
                    {second: 120, pos: {x: -0.3, y: 0, z: 4}}
                ]
            },
            earth: {
                radius: 0.0008 / 109,
                color: "#3687ee",
                scrollSpeed: 0.02,
                keyframes: [
                    {second: 0, pos: {x: 0, y: 0, z: 100}},
                    {second: 110, pos: {x: 0, y: 0, z: 10}},
                    {second: 120, pos: {x: 0, y: 0, z: 0.6}},
                    {second: 130, pos: {x: 0, y: 0, z: 0.4}},
                    {second: 140, pos: {x: 0, y: 0, z: 0.2}},
                    {second: 222, pos: {x: 0, y: 0, z: 0.0425}},
                    {second: 240, pos: {x: 0, y: 0, z: 0.024620689655172414}},
                    {second: 260, pos: {x: 0, y: 0, z: 0.016778067885117494}},
                    {second: 285, pos: {x: 0, y: 0, z: 0.012}}
                ],
                clouds: {
                    back: {scrollSpeed: 0.03, alpha: 0.8},
                    front: {scrollSpeed: 0.03, alpha: 0.5}
                },
                moon: {
                    initialAngle: -1.75,
                    angularVelocity: 0.06,
                    scrollSpeed: 0.01
                }
            },
            earthTiltDeg: 4,
            get journeyDuration() {
                return this.journeySeconds ?? 0;
            }
        };

        function autoExtendJourneySeconds(cfg) {
            const maxS = maxSecondInConfig(cfg);
            if (typeof cfg.journeySeconds !== "number" || cfg.journeySeconds < maxS) {
                cfg.journeySeconds = maxS;
            }
        }

        function maxSecondInConfig(obj) {
            let m = 0;

            function scan(o) {
                if (!o || typeof o !== "object") return;
                if (Array.isArray(o)) {
                    for (const it of o) scan(it);
                    return;
                }
                if (Array.isArray(o.keyframes)) {
                    for (const kf of o.keyframes) {
                        if (kf && typeof kf.second === "number") m = Math.max(m, kf.second);
                    }
                }
                for (const v of Object.values(o)) scan(v);
            }

            scan(obj);
            return m;
        }

        function interpolateVec3(elapsed, keyframes, fallback = {x: 0, y: 0, z: 5}) {
            const withPos = (keyframes || []).filter((k) => k.pos && typeof k.second === "number");
            if (!withPos.length) return fallback;
            withPos.sort((a, b) => a.second - b.second);
            if (elapsed <= withPos[0].second) return withPos[0].pos;
            if (elapsed >= withPos[withPos.length - 1].second) return withPos[withPos.length - 1].pos;
            for (let i = 0; i < withPos.length - 1; i++) {
                const k1 = withPos[i];
                const k2 = withPos[i + 1];
                if (elapsed >= k1.second && elapsed <= k2.second) {
                    const t = (elapsed - k1.second) / (k2.second - k1.second || 1);
                    return {
                        x: k1.pos.x + (k2.pos.x - k1.pos.x) * t,
                        y: k1.pos.y + (k2.pos.y - k1.pos.y) * t,
                        z: k1.pos.z + (k2.pos.z - k1.pos.z) * t
                    };
                }
            }
            return withPos[withPos.length - 1].pos;
        }

        function applyLighting(ctx, cx, cy, radius, options = {}) {
            const {
                offsetX = 0.5,
                offsetY = -0.5,
                innerColor = "rgba(255,255,255,0.9)",
                outerColor = "rgba(0,0,0,0.3)",
                innerRadiusFactor = 0.1
            } = options;
            ctx.save();
            ctx.globalCompositeOperation = "multiply";
            const lightX = cx + radius * offsetX;
            const lightY = cy + radius * offsetY;
            const shade = ctx.createRadialGradient(lightX, lightY, radius * innerRadiusFactor, cx, cy, radius);
            shade.addColorStop(0, innerColor);
            shade.addColorStop(1, outerColor);
            ctx.fillStyle = shade;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function applySpecularHighlight(ctx, cx, cy, radius, options = {}) {
            const {offsetX = 0.5, offsetY = -0.5, sizeFactor = 0.3, color = "rgba(255,255,255,0.6)"} =
                options;
            const lightX = cx + radius * offsetX;
            const lightY = cy + radius * offsetY;
            ctx.save();
            ctx.globalCompositeOperation = "lighter";
            const spec = ctx.createRadialGradient(lightX, lightY, 0, lightX, lightY, radius * sizeFactor);
            spec.addColorStop(0, color);
            spec.addColorStop(1, "rgba(255,255,255,0)");
            ctx.fillStyle = spec;
            ctx.beginPath();
            ctx.arc(lightX, lightY, radius * sizeFactor, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function applyAtmosphere(ctx, cx, cy, radius, options = {}) {
            const {color = "rgba(0,150,255,0.2)", innerAlpha = 0.0} = options;
            ctx.save();
            ctx.globalCompositeOperation = "lighter";
            const atm = ctx.createRadialGradient(cx, cy, radius * 0.9, cx, cy, radius);
            atm.addColorStop(0, `rgba(0,150,255,${innerAlpha})`);
            atm.addColorStop(1, color);
            ctx.fillStyle = atm;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        class AssetManager {
            earthUrl = "./assets/img/earth.png";
            cloudUrl = "./assets/img/cloud.png";
            cloudInvertedUrl = "./assets/img/cloud2.png";
            moonUrl = "./assets/img/moon.png";
            songUrl = "./assets/audio/song.m4a";

            constructor() {
                this.earthSprite = new Image();
                this.cloudOverlay = new Image();
                this.cloudOverlayInverted = new Image();
                this.moonOverlay = new Image();
                this.song = new Audio();
                this.loadAssets();
            }

            loadAssets() {
                this.earthSprite.src = this.earthUrl;
                this.cloudOverlay.src = this.cloudUrl;
                this.cloudOverlayInverted.src = this.cloudInvertedUrl;
                this.moonOverlay.src = this.moonUrl;
                this.song.src = this.songUrl;
                this.song.loop = true;
                this.song.preload = "auto";
                this.song.volume = 0.5;
            }

            getEarthSprite() {
                return this.earthSprite;
            }

            getCloudOverlay() {
                return this.cloudOverlay;
            }

            getCloudOverlayInverted() {
                return this.cloudOverlayInverted;
            }

            getMoonOverlay() {
                return this.moonOverlay;
            }

            getSong() {
                return this.song;
            }
        }

        class Camera {
            constructor(game) {
                this.game = game;
                this.focal = game.config.camera?.focal ?? 600;
                this.cx = 0;
                this.cy = 0;
                this.minDim = 1;
            }

            onResize() {
                const c = this.game.canvas;
                this.cx = c.width / 2;
                this.cy = c.height / 2;
                this.minDim = Math.min(c.width, c.height);
                this.focal = this.game.config.camera?.focal ?? 600;
            }

            project(pos) {
                const z = Math.max(pos.z, 0.001);
                const k = (this.minDim * this.focal) / z;
                return {x: this.cx + pos.x * k, y: this.cy + pos.y * k, k};
            }
        }

        class StarField {
            constructor(game) {
                this.game = game;
                this.farStars = [];
                this.nearStars = [];
                this.width = 1;
                this.height = 1;
                this.centerX = 0.5;
                this.centerY = 0.5;
                this.focal = CONFIG.starfield.focalLength;
                this.cutoffActivated = false;
                this._initStars();
                this.onResize();
            }

            _randCenteredNorm() {
                return (Math.random() - 0.5) * (1 + Math.random() * 0.3);
            }

            _makeStar(isNear) {
                const cfg = this.game.config.starfield;
                const [minS, maxS] = isNear ? cfg.nearSpeedRange : cfg.farSpeedRange;
                return {
                    rx: this._randCenteredNorm(),
                    ry: this._randCenteredNorm(),
                    speed: minS + Math.random() * (maxS - minS),
                    phase: Math.random(),
                    frozen: false,
                    tFreeze: 0,
                    zFreeze: 0,
                    dead: false
                };
            }

            _initStars() {
                const cfg = this.game.config.starfield;
                this.farStars = Array.from({length: cfg.numFar}, () => this._makeStar(false));
                this.nearStars = Array.from({length: cfg.numNear}, () => this._makeStar(true));
            }

            onResize() {
                const c = this.game.canvas;
                this.width = c.width;
                this.height = c.height;
                this.centerX = this.width / 2;
                this.centerY = this.height / 2;
                this.zMax = Math.max(1, this.width / 2);
                this.zMin = Math.max(0.001 * this.width, 1);
                this.zRange = this.zMax - this.zMin;
                this.focal = this.game.config.starfield.focalLength;
            }

            _zAt(star, t) {
                const speed = star.speed * this.game.config.starfield.speedScale;
                const u = ((t * speed + star.phase) % 1 + 1) % 1;
                return this.zMin + (1 - u) * this.zRange;
            }

            _sizeAt(star, z) {
                const base = Math.max(0.5, (0.5 - z / this.zMax) * 5);
                const proximity = star.speed / 8;
                const boost = proximity > 0.5 ? 1 + ((this.zMax - z) / this.zMax) * proximity : 1;
                return Math.max(base * boost, 0.5);
            }

            _project(star, z) {
                const k = this.focal / z;
                const sx = star.rx * this.width * k + this.centerX;
                const sy = star.ry * this.height * k + this.centerY;
                return {sx, sy};
            }

            _drawSet(ctx, stars, t) {
                for (let i = 0; i < stars.length; i++) {
                    const s = stars[i];
                    const z = this._zAt(s, t);
                    const {sx, sy} = this._project(s, z);
                    if (sx >= 0 && sx < this.width && sy >= 0 && sy < this.height) {
                        ctx.beginPath();
                        ctx.arc(sx, sy, this._sizeAt(s, z) / 2, 0, Math.PI * 2);
                        ctx.fillStyle = "#ffffff";
                        ctx.fill();
                    }
                }
            }

            _drawSetFreezeOut(ctx, t) {
                const margin = Math.max(this.width, this.height) * 0.1;
                const vFactor = this.zRange;
                for (let i = 0; i < this.nearStars.length; i++) {
                    const s = this.nearStars[i];
                    if (s.dead) continue;
                    if (!s.frozen) continue;
                    const dt = Math.max(0, t - s.tFreeze);
                    const v = s.speed * this.game.config.starfield.speedScale * vFactor;
                    let z = s.zFreeze - v * dt;
                    z = Math.max(this.zMin * 0.01, z);
                    const {sx, sy} = this._project(s, z);
                    const off =
                        sx < -margin || sx > this.width + margin || sy < -margin || sy > this.height + margin;
                    if (off) {
                        s.dead = true;
                        continue;
                    }
                    ctx.beginPath();
                    ctx.arc(sx, sy, this._sizeAt(s, z) / 2, 0, Math.PI * 2);
                    ctx.fillStyle = "#ffffff";
                    ctx.fill();
                }
            }

            drawFar(ctx) {
                const t = this.game.elapsed || 0;
                this._drawSet(ctx, this.farStars, t);
            }

            drawNear(ctx) {
                const t = this.game.elapsed || 0;
                if (!this.cutoffActivated) {
                    const cut = this.game.config.starfield?.stopNearAt ?? Infinity;
                    if (t < cut) {
                        this._drawSet(ctx, this.nearStars, t);
                        return;
                    }
                }
                this._drawSetFreezeOut(ctx, t);
            }

            update() {
                const t = this.game.elapsed || 0;
                const cut = this.game.config.starfield?.stopNearAt ?? Infinity;
                if (!this.cutoffActivated && t >= cut) {
                    this.cutoffActivated = true;
                    for (let i = 0; i < this.nearStars.length; i++) {
                        const s = this.nearStars[i];
                        s.frozen = true;
                        s.tFreeze = cut;
                        s.zFreeze = this._zAt(s, cut);
                        s.dead = false;
                    }
                } else if (this.cutoffActivated && t < cut) {
                    this.cutoffActivated = false;
                    for (let i = 0; i < this.nearStars.length; i++) {
                        const s = this.nearStars[i];
                        s.frozen = false;
                        s.dead = false;
                    }
                }
            }
        }

        class CelestialBody {
            constructor(game, name) {
                this.game = game;
                this.visible = false;
                this.worldPos = {x: 0, y: 0, z: 5};
                this.name = name;
                this.color = game.config[name].color ?? "#ff00ff";
                this.worldR = game.config[name].radius ?? 0.001;
                this.screen = {x: 0, y: 0, r: 0};
            }

            draw(ctx) {
                if (!this.visible) return;
                ctx.beginPath();
                ctx.arc(this.screen.x, this.screen.y, this.screen.r, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }

            update() {
                const t = this.game.elapsed || 0;
                const kf = this.game.config[this.name].keyframes;
                const pos = interpolateVec3(t, kf, {x: 0, y: 0, z: 5});
                this.worldPos = pos;
                const proj = this.game.camera.project(pos);
                this.screen.x = proj.x;
                this.screen.y = proj.y;
                this.screen.r = Math.max(0, this.worldR * proj.k);
                this.visible = this.screen.r > 0;
            }

            syncToElapsed() {
                this.update();
            }
        }

        class Clouds {
            constructor(game, earthRef) {
                this.game = game;
                this.earthRef = earthRef;
            }

            drawLayer(ctx, img, alpha, cyclesPerSec, invert) {
                const earth = this.earthRef;
                if (!img.complete || !earth.visible || earth.screen.r <= 0) return;
                ctx.save();
                ctx.beginPath();
                ctx.arc(earth.screen.x, earth.screen.y, earth.screen.r / 0.98, 0, Math.PI * 2);
                ctx.clip();
                ctx.globalAlpha = alpha;
                const tilt = (this.game.config.earthTiltDeg || 0) * (Math.PI / 180);
                ctx.translate(earth.screen.x, earth.screen.y);
                ctx.rotate(tilt);
                ctx.imageSmoothingEnabled = false;
                ctx.imageSmoothingQuality = "low";
                const diameter = earth.screen.r * 2;
                const scale = diameter / img.naturalHeight;
                const overlayW = img.naturalWidth * scale;
                const overlayH = diameter;
                const xOrigin = -overlayW / 2;
                const yOrigin = -overlayH / 2;
                const cycles = ((this.game.elapsed || 0) * (cyclesPerSec || 0)) % 1;
                const rawOffset = (invert ? -cycles : cycles) * overlayW;
                const offsetPx = ((rawOffset % overlayW) + overlayW) % overlayW;
                const x2 = xOrigin + offsetPx;
                const x1 = x2 - overlayW;
                ctx.drawImage(img, x1, yOrigin, overlayW + 1, overlayH);
                ctx.drawImage(img, x2, yOrigin, overlayW + 1, overlayH);
                ctx.restore();
            }

            draw(ctx, behind = false) {
                const cloudsCfg = this.game.config.earth.clouds || {};
                const invImg = this.game.assetManager.getCloudOverlayInverted();
                const img = this.game.assetManager.getCloudOverlay();
                if (behind) {
                    if (invImg.complete) {
                        this.drawLayer(
                            ctx,
                            invImg,
                            cloudsCfg.back?.alpha ?? 0.8,
                            cloudsCfg.back?.scrollSpeed ?? 0.015,
                            true
                        );
                    }
                } else {
                    if (img.complete) {
                        this.drawLayer(
                            ctx,
                            img,
                            cloudsCfg.front?.alpha ?? 0.8,
                            cloudsCfg.front?.scrollSpeed ?? 0.03,
                            false
                        );
                    }
                }
            }

            update() {
            }

            syncToElapsed() {
                this.update();
            }
        }

        class Moon {
            constructor(game, earthRef) {
                this.game = game;
                this.earthRef = earthRef;
                this.worldPos = {x: 0, y: 0, z: 5};
                this.worldR = 0;
                this.screen = {x: 0, y: 0, r: 0};
            }

            drawMoonOverlay(ctx, img, cx, cy, moonSize, cycles) {
                if (!img.complete) return;
                ctx.save();
                ctx.beginPath();
                ctx.arc(cx, cy, moonSize / 2, 0, Math.PI * 2);
                ctx.clip();
                const scale = moonSize / img.naturalHeight;
                const overlayW = img.naturalWidth * scale;
                const overlayH = moonSize;
                const xOrigin = cx - overlayW / 2;
                const yOrigin = cy - overlayH / 2;
                const offsetPx = (cycles % 1) * overlayW;
                ctx.drawImage(img, xOrigin + offsetPx, yOrigin, overlayW, overlayH);
                ctx.drawImage(img, xOrigin + offsetPx - overlayW, yOrigin, overlayW, overlayH);
                ctx.restore();
            }

            draw(ctx, behind = false) {
                const earth = this.earthRef;
                if (!earth.visible || earth.screen.r <= 0) return;
                const cfg = this.game.config.earth.moon || {};
                const elapsed = this.game.elapsed || 0;
                const angle = (cfg.initialAngle ?? -1.75) + (cfg.angularVelocity ?? 0.06) * elapsed;
                const orbit = earth.worldR * 5.6;
                const mx = earth.worldPos.x + Math.sin(angle) * orbit;
                const my = earth.worldPos.y + Math.cos(angle) * orbit * 0.1;
                const mz = earth.worldPos.z;
                this.worldPos = {x: mx, y: my, z: mz};
                this.worldR = earth.worldR * 0.15;
                const proj = this.game.camera.project(this.worldPos);
                this.screen.x = proj.x;
                this.screen.y = proj.y;
                this.screen.r = Math.max(0, this.worldR * proj.k);
                const depth = Math.cos(angle);
                const isBehind = depth < 0;
                if (behind === isBehind) {
                    const cycles = ((cfg.scrollSpeed ?? 0.5) * elapsed) % 1;
                    this.drawMoonOverlay(
                        this.game.ctx,
                        this.game.assetManager.getMoonOverlay(),
                        this.screen.x,
                        this.screen.y,
                        this.screen.r * 2,
                        cycles
                    );
                    const moonArgs = [this.game.ctx, this.screen.x, this.screen.y, this.screen.r];
                    applyLighting(...moonArgs, {
                        offsetX: 0,
                        offsetY: 0,
                        innerColor: behind ? "rgba(255,255,255,0.1)" : "rgba(255,255,255,0.2)",
                        outerColor: "rgba(80,80,80,0.1)"
                    });
                    applySpecularHighlight(...moonArgs, {
                        offsetX: -0.2,
                        offsetY: 0.2,
                        sizeFactor: 0.8,
                        color: behind ? "rgba(255,255,255,0.08)" : "rgba(255,255,255,0.1)"
                    });
                }
            }

            update() {
            }

            syncToElapsed() {
                this.update();
            }
        }

        class Earth extends CelestialBody {
            constructor(game) {
                super(game, "earth");
                this.game = game;
                this.visible = false;
                this.worldPos = {x: 0, y: 0, z: 6};
                this.worldR = game.config.earth.radius ?? 0.002;
                this.screen = {x: 0, y: 0, r: 0};
                this.moon = new Moon(game, this);
                this.clouds = new Clouds(game, this);
            }

            draw(ctx) {
                if (!this.visible || this.screen.r <= 0) return;
                const earthImg = this.game.assetManager.getEarthSprite();
                if (!earthImg.complete) return;
                ctx.save();
                ctx.imageSmoothingEnabled = false;
                ctx.imageSmoothingQuality = "low";
                ctx.beginPath();
                ctx.arc(this.screen.x, this.screen.y, this.screen.r, 0, Math.PI * 2);
                ctx.clip();
                const tilt = (this.game.config.earthTiltDeg || 0) * (Math.PI / 180);
                ctx.translate(this.screen.x, this.screen.y);
                ctx.rotate(tilt);
                const diameter = this.screen.r * 2;
                const scale = diameter / earthImg.naturalHeight;
                const overlayW = earthImg.naturalWidth * scale;
                const overlayH = diameter;
                const xOrigin = -overlayW / 2;
                const yOrigin = -overlayH / 2;
                const cycles = ((this.game.config.earth.scrollSpeed ?? 0) * (this.game.elapsed || 0)) % 1;
                const offsetPx = (cycles % 1) * overlayW;
                const x1 = xOrigin + offsetPx;
                const x2 = x1 - overlayW;
                ctx.drawImage(earthImg, x1, yOrigin, overlayW, overlayH);
                ctx.drawImage(earthImg, x2, yOrigin, overlayW, overlayH);
                ctx.restore();
                const baseX = -0.2;
                const baseY = 0.2;
                const offX = baseX * Math.cos(tilt) - baseY * Math.sin(tilt);
                const offY = baseX * Math.sin(tilt) + baseY * Math.cos(tilt);
                applyLighting(this.game.ctx, this.screen.x, this.screen.y, this.screen.r / 0.96, {
                    offsetX: offX,
                    offsetY: offY,
                    innerColor: "rgba(255,255,255,0.1)",
                    outerColor: "rgba(80,80,80,0.08)"
                });
                applySpecularHighlight(this.game.ctx, this.screen.x, this.screen.y, this.screen.r / 0.96, {
                    offsetX: offX,
                    offsetY: offY,
                    sizeFactor: 0.8,
                    color: "rgba(255,255,255,0.2)"
                });
                applyAtmosphere(this.game.ctx, this.screen.x, this.screen.y, this.screen.r / 0.96, {
                    color: "rgba(148,210,255,0.2)"
                });
            }

            drawChildren(ctx) {
                if (!this.visible || this.screen.r <= 0) return;
                this.moon.draw(ctx, true);
                this.clouds.draw(ctx, true);
                this.draw(ctx);
                this.clouds.draw(ctx, false);
                this.moon.draw(ctx, false);
            }

            syncToElapsed() {
                this.update();
                this.moon.update();
                this.clouds.update();
                this.moon.syncToElapsed();
                this.clouds.syncToElapsed();
            }
        }

        class AudioPlayer {
            constructor(game) {
                this.game = game;
                this.audio = this.game.assetManager.getSong();
                this.isPlaying = false;
                this.setVolume(0.5);
            }

            play() {
                this.audio.play();
                this.isPlaying = true;
            }

            pause() {
                this.audio.pause();
                this.isPlaying = false;
            }

            toggle() {
                this.isPlaying ? this.pause() : this.play();
            }

            setVolume(v) {
                this.audio.volume = Math.max(0, Math.min(1, v));
            }

            seekTo(seconds) {
                const a = this.audio;
                const target = Math.max(0, Number(seconds) || 0);
                if (!isNaN(a.duration) && isFinite(a.duration)) {
                    a.currentTime = Math.max(0, Math.min(a.duration, target));
                } else {
                    a.currentTime = target;
                }
            }

            getDuration() {
                const d = this.audio.duration;
                return isFinite(d) ? d : 0;
            }

            getCurrentTime() {
                return typeof this.audio.currentTime === "number" ? this.audio.currentTime : 0;
            }

            addEventListener(type, handler) {
                this.audio.addEventListener(type, handler);
            }
        }

        class UI {
            constructor(game) {
                this.game = game;
                this.canvas = game.canvas;
                this.controlsRoot = document.getElementById("audio-controls");
                this.btn = document.getElementById("music-toggle");
                this.volume = document.getElementById("music-volume");
                this.timeSlider = null;
            }

            initControls() {
                this.btn.addEventListener("click", () => {
                    this.game.play = !this.game.play;
                    if (this.game.play) this.game.audio.play();
                    else this.game.audio.pause();
                    this.updatePlayButton();
                });
                this.volume.addEventListener("input", (e) =>
                    this.game.audio.setVolume(parseFloat(e.target.value))
                );
                this.timeSlider = document.createElement("input");
                this.timeSlider.className = "timeline";
                this.timeSlider.type = "range";
                this.timeSlider.min = 0;
                this.timeSlider.max = this.game.config.journeyDuration;
                this.timeSlider.step = 0.01;
                this.timeSlider.value = 0;
                this.controlsRoot.appendChild(this.timeSlider);
                const onScrub = (sec) => {
                    this.game.audio.seekTo(sec);
                    this.game.syncToElapsed();
                };
                this.timeSlider.addEventListener("input", (e) => onScrub(e.target.value));
                this.timeSlider.addEventListener("change", (e) => onScrub(e.target.value));
                this.game.audio.addEventListener("loadedmetadata", () => {
                    this.game.syncJourneySecondsFromAudio();
                });
            }

            updatePlayButton() {
                this.btn.textContent = this.game.play ? "Pause" : "Play";
            }

            setSliderValue(v) {
                if (this.timeSlider) this.timeSlider.value = v;
            }

            setSliderMax(v) {
                if (this.timeSlider) this.timeSlider.max = v;
            }

            drawTimer(ctx, elapsedSec, totalSec) {
                ctx.fillStyle = "#FFF";
                ctx.font = "16px monospace";
                const secs = Math.floor(elapsedSec);
                const mins = Math.floor(secs / 60);
                const rsec = secs % 60;
                const tsec = Math.floor(totalSec);
                const tmin = Math.floor(tsec / 60);
                const trsec = tsec % 60;
                const fmt = (n) => (n < 10 ? "0" + n : "" + n);
                ctx.fillText(`${fmt(mins)}:${fmt(rsec)} / ${fmt(tmin)}:${fmt(trsec)}`, 10, 25);
            }

            drawSpeed(ctx, speed) {
                ctx.fillStyle = "#FFF";
                ctx.font = "16px monospace";
                ctx.fillText(`Speed: ${speed.toFixed(2)}`, 10, 45);
            }
        }

        class SpaceJourneyGame {
            constructor() {
                this.canvas = document.getElementById("viaje");
                this.ctx = this.canvas.getContext("2d");
                this.config = CONFIG;
                this.play = false;
                this.assetManager = new AssetManager();
                this.camera = new Camera(this);
                this.stars = new StarField(this);
                this.sun = new CelestialBody(this, "sun");
                this.mars = new CelestialBody(this, "mars");
                this.jupiter = new CelestialBody(this, "jupiter");
                this.earth = new Earth(this);
                this.audio = new AudioPlayer(this);
                this.ui = new UI(this);
                this.elapsed = 0;
                autoExtendJourneySeconds(this.config);
                this.resizeCanvas();
                this.bindWindowEvents();
                this.ui.initControls();
                this.animate();
            }

            bindWindowEvents() {
                window.addEventListener("resize", () => this.resizeCanvas());
            }

            syncJourneySecondsFromAudio() {
                const dur = this.audio.getDuration();
                const maxFromConfig = maxSecondInConfig(this.config);
                this.config.journeySeconds = Math.max(
                    this.config.journeySeconds || 0,
                    maxFromConfig,
                    dur
                );
                this.ui.setSliderMax(this.config.journeyDuration);
            }

            syncToElapsed() {
                this.sun.syncToElapsed?.();
                this.mars.syncToElapsed?.();
                this.jupiter.syncToElapsed?.();
                this.earth.syncToElapsed?.();
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.camera.onResize();
                this.stars.onResize();
            }

            drawBackground(ctx) {
                ctx.fillStyle = "#000";
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            update() {
                this.sun.update();
                this.mars.update();
                this.jupiter.update();
                this.earth.update();
                this.stars.update();
            }

            draw() {
                this.drawBackground(this.ctx);
                this.stars.drawFar(this.ctx);
                this.stars.drawNear(this.ctx);
                if (this.earth.visible && this.earth.screen.r > 0) {
                    this.earth.drawChildren(this.ctx);
                }
                this.sun.draw(this.ctx);
                this.mars.draw(this.ctx);
                this.jupiter.draw(this.ctx);
                this.ui.drawTimer(this.ctx, this.elapsed, this.config.journeyDuration);
            }

            animate() {
                this.elapsed = this.audio.getCurrentTime();
                if (this.play) {
                    this.update();
                } else {
                    this.syncToElapsed();
                }
                this.ui.setSliderValue(this.elapsed);
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }

        document.addEventListener("DOMContentLoaded", () => {
            new SpaceJourneyGame();
        });
    </script>
</body>
</html>
