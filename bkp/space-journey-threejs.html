<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Viaje espacial a la Tierra (Three.js)</title>
    <style>
        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: #000;
        }
        #timer {
            position: absolute; top: 10px; left: 10px; color: #fff;
            font-family: monospace; font-size: 14px; z-index: 10; user-select: none;
        }
    </style>
</head>
<body>
<div id="timer"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    const CONFIG = {
        initialSpeed: 20,
        minSpeed: 0.5,
        journeyMinutes: 0.1, // ~6s
        get journeyDuration() { return this.journeyMinutes * 60 * 1000; },
        get earthAppearTime() { return this.journeyDuration / 2; },
        get earthDuration() { return this.journeyDuration - this.earthAppearTime; },
        get stopSpawnTime() { return this.earthAppearTime - 10000; },
        numStars: 500
    };

    let scene, camera, renderer;
    let stars = [];
    let earth, clouds1, clouds2, moon;
    let sunLight, sunMesh, ambientLight;
    let startTime, elapsed = 0;
    let shipSpeed = CONFIG.initialSpeed;
    let progress = 0, eased = 0;
    let timerDiv;

    // Texturas
    let earthTexture, moonTexture, cloudsTexture, clouds2Texture;

    function init() {
        timerDiv = document.getElementById('timer');

        scene = new THREE.Scene();

        const aspect = window.innerWidth / window.innerHeight;
        camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 5000);
        camera.position.set(0, 0, 500);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        // Mejora de color en texturas sRGB
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        // Luces
        sunLight = new THREE.PointLight(0xffddaa, 1.5, 0, 2);
        sunLight.position.set(-50, 50, 100);
        scene.add(sunLight);

        ambientLight = new THREE.AmbientLight(0x222222);
        scene.add(ambientLight);

        const sunGeom = new THREE.SphereGeometry(5, 32, 32);
        const sunMat = new THREE.MeshBasicMaterial({ color: 0xffddaa });
        sunMesh = new THREE.Mesh(sunGeom, sunMat);
        sunMesh.position.copy(sunLight.position);
        scene.add(sunMesh);

        // Campo de estrellas
        const starGeom = new THREE.SphereGeometry(1, 6, 6);
        const maxDistance = 2000;
        const starFieldRange = 400;
        for (let i = 0; i < CONFIG.numStars; i++) {
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const star = new THREE.Mesh(starGeom, starMat);
            star.userData = {
                speedFactor: 0.3 + Math.random() * 0.7,
                starFieldRange,
                maxDistance
            };
            resetStar(star, maxDistance, starFieldRange);
            scene.add(star);
            stars.push(star);
        }

        // Cargar texturas
        const loader = new THREE.TextureLoader();
        earthTexture  = loader.load('earth.png', t => { t.encoding = THREE.sRGBEncoding; });
        moonTexture   = loader.load('moon.png',  t => { t.encoding = THREE.sRGBEncoding; });
        cloudsTexture = loader.load('cloud.png');
        clouds2Texture= loader.load('cloud2.png');

        // Tierra
        const earthGeom = new THREE.SphereGeometry(1, 64, 64);
        const earthMat = new THREE.MeshStandardMaterial({
            map: earthTexture,
            roughness: 0.9,
            metalness: 0.0
        });
        earth = new THREE.Mesh(earthGeom, earthMat);
        earth.visible = false;
        scene.add(earth);

        // Nubes (dos capas, radios ligeramente mayores y opacidades distintas)
        const cloudGeom1 = new THREE.SphereGeometry(1.02, 64, 64);
        const cloudMat1 = new THREE.MeshLambertMaterial({
            map: cloudsTexture,
            transparent: true,
            opacity: 0.8,
            depthWrite: false
        });
        clouds1 = new THREE.Mesh(cloudGeom1, cloudMat1);
        clouds1.visible = false;
        scene.add(clouds1);

        const cloudGeom2 = new THREE.SphereGeometry(1.04, 64, 64);
        const cloudMat2 = new THREE.MeshLambertMaterial({
            map: clouds2Texture,
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        clouds2 = new THREE.Mesh(cloudGeom2, cloudMat2);
        clouds2.visible = false;
        scene.add(clouds2);

        // Luna
        const moonGeom = new THREE.SphereGeometry(0.27, 32, 32);
        const moonMat = new THREE.MeshStandardMaterial({
            map: moonTexture,
            roughness: 1.0,
            metalness: 0.0
        });
        moon = new THREE.Mesh(moonGeom, moonMat);
        moon.visible = false;
        scene.add(moon);

        window.addEventListener('resize', onWindowResize);
        startTime = performance.now();
        animate();
    }

    function resetStar(star, maxDistance, fieldRange) {
        let range = (fieldRange ?? star.userData.starFieldRange ?? 400);
        star.position.x = (Math.random() * 2 - 1) * range;
        star.position.y = (Math.random() * 2 - 1) * range;
        let dist = (maxDistance ?? star.userData.maxDistance ?? 2000);
        star.position.z = -Math.random() * dist;
        const scale = 0.5 + Math.random() * 0.7;
        star.scale.set(scale, scale, scale);
        star.visible = true;
    }

    function updateSpeed() {
        const initialSpeed = CONFIG.initialSpeed;
        const midSp = initialSpeed * 0.25;
        if (elapsed <= CONFIG.earthAppearTime) {
            const t = elapsed / CONFIG.earthAppearTime;
            shipSpeed = initialSpeed - (initialSpeed - midSp) * t;
        } else {
            const t2 = (elapsed - CONFIG.earthAppearTime) / CONFIG.earthDuration;
            shipSpeed = midSp - (midSp - CONFIG.minSpeed) * Math.min(t2, 1);
        }
    }

    function updateProgress() {
        progress = (elapsed - CONFIG.earthAppearTime) / CONFIG.earthDuration;
        progress = Math.min(Math.max(progress, 0), 1);
        eased = Math.pow(progress, 3);
    }

    function updateStars() {
        const maxD = 2000;
        stars.forEach(star => {
            star.position.z += shipSpeed * star.userData.speedFactor;
            const camZ = camera.position.z;
            const maxDist = (star.userData.maxDistance ?? 2000);
            const relativeDepth = (camZ - star.position.z) / (camZ + maxDist);
            const clamped = Math.max(Math.min(relativeDepth, 1), 0);
            const sizeScale = 0.5 + (1 - clamped) * 1.5;
            star.scale.set(sizeScale, sizeScale, sizeScale);

            if (star.position.z >= camZ) {
                if (elapsed < CONFIG.stopSpawnTime) {
                    resetStar(star, maxD, star.userData.starFieldRange);
                } else {
                    star.position.z = camZ;
                    star.visible = false;
                }
            }
        });
    }

    function updateMoon() {
        if (!moon.visible) return;
        const angle = elapsed * 0.001;
        const earthRadius = earth.scale.x;
        const orbit = earthRadius * 2.2;
        const xOff = Math.sin(angle) * orbit;
        const yOff = Math.cos(angle) * orbit * 0.3;
        const zOff = Math.cos(angle) * orbit * 0.8;
        moon.position.set(xOff, yOff, -zOff);
        moon.rotation.y += 0.02;
    }

    function updateEarthAndClouds() {
        if (progress > 0) {
            earth.visible = true;
            clouds1.visible = true;
            clouds2.visible = true;
            moon.visible = true;

            const finalRadius = 150;
            const currentRadius = eased * finalRadius;
            earth.scale.set(currentRadius, currentRadius, currentRadius);

            const cloudR1 = currentRadius * 1.02;
            const cloudR2 = currentRadius * 1.04;
            clouds1.scale.set(cloudR1, cloudR1, cloudR1);
            clouds2.scale.set(cloudR2, cloudR2, cloudR2);
        }
    }

    function updateTimer() {
        const secs = Math.floor(elapsed / 1000);
        const mins = Math.floor(secs / 60);
        const rsec = secs % 60;
        const totalSeconds = CONFIG.journeyMinutes * 60;
        const totMin = Math.floor(totalSeconds / 60);
        const rTotSec = Math.round(totalSeconds % 60);
        const fmt = n => n < 10 ? '0' + n : '' + n;
        timerDiv.textContent = `${fmt(mins)}:${fmt(rsec)} / ${fmt(totMin)}:${fmt(rTotSec)}`;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        const maxD = 2000;
        stars.forEach(star => resetStar(star, maxD, star.userData.starFieldRange));
    }

    function animate() {
        requestAnimationFrame(animate);
        elapsed = performance.now() - startTime;
        updateSpeed();
        updateProgress();
        updateStars();
        updateEarthAndClouds();
        updateMoon();
        updateTimer();

        if (earth.visible) {
            // Rotaci√≥n suave: Tierra y nubes en sentidos opuestos
            earth.rotation.y  += 0.001;
            clouds1.rotation.y += 0.0006;
            clouds2.rotation.y -= 0.0008;
        }

        renderer.render(scene, camera);
    }

    document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
