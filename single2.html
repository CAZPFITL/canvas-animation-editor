<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <title>Star Fields</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        #viaje {
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }
    </style>
</head>
<body class="m-0 h-screen bg-black overflow-hidden">
<canvas id="viaje" class="block w-full h-full"></canvas>
<div class="fixed bottom-0 left-0 right-0 z-20 bg-black/70 backdrop-blur-sm border-t border-white/10 opacity-0 hover:opacity-100 transition">
    <div class="flex items-center gap-3 px-3 py-2 text-white">
        <button id="music-toggle"
                class="grid place-items-center w-9 h-9 rounded-full bg-white/10 hover:bg-white/20 transition">
            <svg class="w-4 h-4" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                <path d="M8 5v14l11-7-11-7z"/>
            </svg>
        </button>
        <div id="ui-timer" class="text-xs sm:text-sm font-mono tabular-nums select-none px-1">
            <span id="uiTimeNow">00:00</span> / <span id="uiTimeTotal">00:00</span>
        </div>
        <div class="flex-1 px-2">
            <input id="timeSlider" type="range" min="0" max="100" step="0.01" value="0"
                   class="w-full accent-blue-500 h-2 rounded-lg cursor-pointer"/>
        </div>
        <div class="flex items-center gap-2">
            <div class="grid place-items-center w-9 h-9 rounded-full bg-white/10">
                <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                    <path d="M5 9v6h4l5 5V4L9 9H5z"/>
                    <path d="M16 7v2c1.7 0 3 1.3 3 3s-1.3 3-3 3v2c2.8 0 5-2.2 5-5s-2.2-5-5-5z"/>
                </svg>
            </div>
            <input id="music-volume" type="range" min="0" max="1" step="0.01" value="0.5"
                   class="w-28 md:w-36 accent-blue-500 h-2 rounded-lg cursor-pointer"/>
        </div>
        <button id="fs-toggle"
                class="grid place-items-center w-9 h-9 rounded-full bg-white/10 hover:bg-white/20 transition">
            <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                <path d="M7 3H3v4h2V5h2V3zm14 0h-4v2h2v2h2V3zM5 17H3v4h4v-2H5v-2zm16 0h-2v2h-2v2h4v-4z"/>
            </svg>
        </button>
    </div>
</div>
<script>
    const CONFIG = {
        journeySeconds: 285,
        camera: {focal: 600},
        starFields: [
            {
                name: "bg",
                shape: "circle",
                zRange: [4000, 22000],
                behindBodies: true,
                keyframes: [
                    {
                        second: 0,
                        count: 500,
                        size: 1.5,
                        speed: 8,
                        focalAngleDeg: 0,
                        focalRadius: 0,
                        twinkle: 0.01,
                        trail: 0,
                        spawnSpread: Math.PI / 2.5,
                        ease: "linear"
                    },
                    {second: 100, speed: 6, ease: "linear"},
                    {second: 126.8, speed: 2, ease: "linear"}
                ]
            },
            {
                name: "far",
                shape: "circle",
                zRange: [4000, 22000],
                behindBodies: true,
                keyframes: [
                    {
                        second: 0,
                        count: 400,
                        size: 2,
                        speed: 200,
                        focalAngleDeg: 0,
                        focalRadius: 0,
                        twinkle: 0.01,
                        trail: 0,
                        spawnSpread: Math.PI / 0.3,
                        ease: "linear"
                    },
                    {second: 100, speed: 100, ease: "linear"},
                    {second: 126.8, speed: 4, ease: "linear"}
                ]
            },
            {
                name: "middle",
                shape: "square",
                zRange: [20, 22000],
                behindBodies: false,
                keyframes: [
                    {
                        second: 0,
                        count: 300,
                        size: 2.2,
                        speed: 2000,
                        focalAngleDeg: 0,
                        focalRadius: 0,
                        twinkle: 0,
                        trail: 0.8,
                        spawnSpread: Math.PI/0.2,
                        ease: "linear"
                    },
                    {second: 100, count: 0, trail: 0, speed: 400, ease: "linear"}
                ]
            },
            {
                name: "near",
                shape: "square",
                zRange: [20, 12000],
                behindBodies: false,
                keyframes: [
                    {
                        second: 0,
                        count: 160,
                        size: 2.4,
                        speed: 2500,
                        focalAngleDeg: 0,
                        focalRadius: 0,
                        twinkle: 0,
                        trail: 1.5,
                        spawnSpread: Math.PI/0.5,
                        ease: "linear"
                    },
                    {second: 100, count: 0, trail: 0, speed: 400, ease: "linear"}
                ]
            },
            {
                name: "nearest",
                shape: "square",
                zRange: [20, 12000],
                behindBodies: false,
                keyframes: [
                    {
                        second: 0,
                        count: 80,
                        size: 2.6,
                        speed: 6000,
                        focalAngleDeg: 0,
                        focalRadius: 0,
                        twinkle: 0,
                        trail: 3,
                        spawnSpread: Math.PI,
                        ease: "linear"
                    },
                    {second: 100, count: 0, trail: 0, speed: 400, ease: "linear"}
                ]
            },
            {
                name: "closer",
                shape: "square",
                zRange: [20, 12000],
                behindBodies: false,
                keyframes: [
                    {
                        second: 0,
                        count: 40,
                        size: 2.8   ,
                        speed: 6000,
                        focalAngleDeg: 0,
                        focalRadius: 0,
                        twinkle: 0,
                        trail: 3,
                        spawnSpread: Math.PI/5,
                        ease: "linear"
                    },
                    {second: 100, count: 0, trail: 0, speed: 400, ease: "linear"}
                ]
            }
        ],
        sun: {
            radius: 0.0008 / 1.6,
            color: "#ffcc00",
            keyframes: [
                {second: 0, pos: {x: 0, y: 0, z: 20000}},
                {second: 100, pos: {x: 0, y: 0, z: 1000}},
                {second: 110},
                {second: 122, pos: {x: -0.03, y: 0, z: 0}}
            ]
        },
        mercury: {
            radius: 0.0008 / 4,
            color: "#b4bdc7",
            keyframes: [
                {second: 0, pos: {x: 0, y: 0, z: 20000}},
                {second: 100, pos: {x: 0, y: 0, z: 1000}},
                {second: 122.7, pos: {x: 0.005, y: -0.001, z: 0}}
            ]
        },
        venus: {
            radius: 0.0008 / 2,
            color: "#f2f2f2",
            keyframes: [
                {second: 0, pos: {x: 0, y: 0, z: 20000}},
                {second: 100, pos: {x: 0, y: 0, z: 1000}},
                {second: 123, pos: {x: -0.25, y: 0, z: 0}}
            ]
        },
        mars: {
            radius: 0.0008 / 2.5,
            color: "#b75741",
            keyframes: [
                {second: 0, pos: {x: 0, y: 0, z: 20000}},
                {second: 100, pos: {x: 0, y: 0, z: 1000}},
                {second: 120.5, pos: {x: 0.05, y: -0.002, z: 0}}
            ]
        },
        jupiter: {
            radius: 0.0008,
            color: "#f3e8a3",
            keyframes: [
                {second: 0, pos: {x: 0, y: 0, z: 20000}},
                {second: 100, pos: {x: 0, y: 0, z: 1000}},
                {second: 118, pos: {x: -0.3, y: 0, z: 4}}
            ]
        },
        saturn: {
            radius: 0.0008 / 2,
            color: "#C8B38B",
            keyframes: [
                {second: 0, pos: {x: 0, y: 0, z: 20000}},
                {second: 100, pos: {x: 0, y: 0, z: 1000}},
                {second: 116, pos: {x: -0.1, y: 0, z: 0}}
            ]
        },
        uranus: {
            radius: 0.0008 / 2,
            color: "#7FFFD4",
            keyframes: [
                {second: 0, pos: {x: 0, y: 0, z: 20000}},
                {second: 100, pos: {x: 0, y: 0, z: 1000}},
                {second: 117, pos: {x: -0.3, y: 0, z: 4}}
            ]
        },
        neptune: {
            radius: 0.0008 / 2,
            color: "#bfc4ff",
            keyframes: [
                {second: 0, pos: {x: 0, y: 0, z: 20000}},
                {second: 100, pos: {x: 0, y: 0, z: 1000}},
                {second: 115.6, pos: {x: 0.02, y: 0.006, z: 0}}
            ]
        },
        earth: {
            radius: 0.0008 / 109,
            color: "#3687ee",
            scrollSpeed: 0.0007,
            keyframes: [
                {second: 0, pos: {x: 0, y: 0, z: 100}, ease: "expoOut"},
                {second: 118, pos: {x: 0, y: 0, z: 10}, ease: "cubicInOut"},
                {second: 126.8, pos: {x: 0, y: 0, z: 0.2}, ease: "smoothstep"},
                {second: 256, pos: {x: 0, y: 0, z: 0.018}},
                {second: 380, pos: {x: 0, y: 0, z: 0.0095}}
            ],
            clouds: {back: {scrollSpeed: 0.0016, alpha: 0.8}, front: {scrollSpeed: 0.0016, alpha: 0.5}}
        },
        moon: {
            color: "#bbbbbb",
            radiusFactor: 0.15,
            orbit: {
                parent: "earth",
                distanceFactor: 11,
                inclinationDeg: 6,
                verticalFlatten: 0.02,
                angularVelocity: 0.045,
                initialAngle: -1.75
            },
            scrollSpeed: 0.01
        },
        earthTiltDeg: 4,
        get journeyDuration() {
            return this.journeySeconds ?? 0;
        }
    };

    const Easings = {
        linear: t => t,
        quadIn: t => t * t,
        quadOut: t => 1 - (1 - t) * (1 - t),
        quadInOut: t => (t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2),
        cubicInOut: t => (t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2),
        expoOut: t => (t === 1 ? 1 : 1 - Math.pow(2, -10 * t)),
        smoothstep: t => t * t * (3 - 2 * t),
        bezierY: ([, y1, , y2]) => t => {
            const u = 1 - t;
            return u * u * u * 0 + 3 * u * u * t * y1 + 3 * u * t * t * y2 + t * t * t * 1;
        }
    };

    function getEaseFn(k1, k2) {
        const e = k1?.ease ?? k2?.ease ?? "linear";
        if (typeof e === "string" && Easings[e]) return Easings[e];
        if (Array.isArray(e) && e.length === 4) return Easings.bezierY(e);
        return Easings.linear;
    }

    function autoExtendJourneySeconds() {
        const maxS = maxSecondInConfig(CONFIG);
        if (typeof CONFIG.journeySeconds !== "number" || CONFIG.journeySeconds < maxS) CONFIG.journeySeconds = maxS;
    }

    function maxSecondInConfig(obj) {
        let m = 0;

        function scan(o) {
            if (!o || typeof o !== "object") return;
            if (Array.isArray(o)) {
                for (const it of o) scan(it);
                return;
            }
            if (Array.isArray(o.keyframes)) {
                for (const kf of o.keyframes) if (kf && typeof kf.second === "number") m = Math.max(m, kf.second);
            }
            for (const v of Object.values(o)) scan(v);
        }

        scan(obj);
        return m;
    }

    function interpolateVec3(elapsed, keyframes, fallback = {x: 0, y: 0, z: 5}) {
        const withPos = (keyframes || []).filter(k => k.pos && typeof k.second === "number").sort((a, b) => a.second - b.second);
        if (!withPos.length) return fallback;
        if (elapsed <= withPos[0].second) return withPos[0].pos;
        if (elapsed >= withPos[withPos.length - 1].second) return withPos[withPos.length - 1].pos;
        for (let i = 0; i < withPos.length - 1; i++) {
            const k1 = withPos[i], k2 = withPos[i + 1];
            if (elapsed >= k1.second && elapsed <= k2.second) {
                const rawT = (elapsed - k1.second) / (k2.second - k1.second || 1);
                const ease = getEaseFn(k1, k2);
                const t = ease(Math.max(0, Math.min(1, rawT)));
                return {
                    x: k1.pos.x + (k2.pos.x - k1.pos.x) * t,
                    y: k1.pos.y + (k2.pos.y - k1.pos.y) * t,
                    z: k1.pos.z + (k2.pos.z - k1.pos.z) * t
                };
            }
        }
        return withPos[withPos.length - 1].pos;
    }

    function applyLighting(ctx, cx, cy, radius, options = {}) {
        const {
            offsetX = 0.5,
            offsetY = -0.5,
            innerColor = "rgba(255,255,255,0.9)",
            outerColor = "rgba(0,0,0,0.3)",
            innerRadiusFactor = 0.1
        } = options;
        ctx.save();
        ctx.globalCompositeOperation = "multiply";
        const lightX = cx + radius * offsetX, lightY = cy + radius * offsetY;
        const shade = ctx.createRadialGradient(lightX, lightY, radius * innerRadiusFactor, cx, cy, radius);
        shade.addColorStop(0, innerColor);
        shade.addColorStop(1, outerColor);
        ctx.fillStyle = shade;
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    function applySpecularHighlight(ctx, cx, cy, radius, options = {}) {
        const {offsetX = 0.5, offsetY = -0.5, sizeFactor = 0.3, color = "rgba(255,255,255,0.6)"} = options;
        const lightX = cx + radius * offsetX, lightY = cy + radius * offsetY;
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        const spec = ctx.createRadialGradient(lightX, lightY, 0, lightX, lightY, radius * sizeFactor);
        spec.addColorStop(0, color);
        spec.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = spec;
        ctx.beginPath();
        ctx.arc(lightX, lightY, radius * sizeFactor, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    function applyAtmosphere(ctx, cx, cy, radius, options = {}) {
        const {color = "rgba(0,150,255,0.2)", innerAlpha = 0.0} = options;
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        const atm = ctx.createRadialGradient(cx, cy, radius * 0.9, cx, cy, radius);
        atm.addColorStop(0, `rgba(0,150,255,${innerAlpha})`);
        atm.addColorStop(1, color);
        ctx.fillStyle = atm;
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    class AssetManager {
        earthUrl = "./assets/img/earth.png";
        cloudUrl = "./assets/img/cloud.png";
        cloudInvertedUrl = "./assets/img/cloud2.png";
        moonUrl = "./assets/img/moon.png";
        songUrl = "./assets/audio/song.m4a";

        constructor() {
            this.earthSprite = new Image();
            this.cloudOverlay = new Image();
            this.cloudOverlayInverted = new Image();
            this.moonOverlay = new Image();
            this.song = new Audio();
            this.loadAssets();
        }

        loadAssets() {
            this.earthSprite.src = this.earthUrl;
            this.cloudOverlay.src = this.cloudUrl;
            this.cloudOverlayInverted.src = this.cloudInvertedUrl;
            this.moonOverlay.src = this.moonUrl;
            this.song.src = this.songUrl;
            this.song.loop = true;
            this.song.preload = "auto";
            this.song.volume = 0.5;
        }

        getEarthSprite() {
            return this.earthSprite
        }

        getCloudOverlay() {
            return this.cloudOverlay
        }

        getCloudOverlayInverted() {
            return this.cloudOverlayInverted
        }

        getMoonOverlay() {
            return this.moonOverlay
        }

        getSong() {
            return this.song
        }
    }

    class Camera {
        constructor(game) {
            this.game = game;
            this.focal = CONFIG.camera?.focal ?? 600;
            this.cx = 0;
            this.cy = 0;
            this.minDim = 1;
            this.origin = {x: 0, y: 0};
        }

        onResize() {
            const c = this.game.canvas;
            this.cx = c.width / 2;
            this.cy = c.height / 2;
            this.minDim = Math.min(c.width, c.height);
            this.focal = CONFIG.camera?.focal ?? 600;
        }

        isInFront(pos) {
            return (pos?.z || 0) > 0
        }

        update() {
            this.origin.x = 0;
            this.origin.y = 0
        }

        project(pos) {
            const relX = pos.x - this.origin.x, relY = pos.y - this.origin.y;
            const z = Math.max(pos.z, 0.001);
            const k = (this.minDim * this.focal) / z;
            return {x: this.cx + relX * k, y: this.cy + relY * k, k};
        }
    }

    class CelestialBody {
        constructor(game, name) {
            this.game = game;
            this.name = name;
            const cfg = CONFIG[name] || {};
            this.visible = false;
            this.worldPos = {x: 0, y: 0, z: 5};
            this.color = cfg.color ?? "#ff00ff";
            this.worldR = cfg.radius ?? 0.001;
            this.screen = {x: 0, y: 0, r: 0};
            this.keyframes = cfg.keyframes || null;
            this.orbit = cfg.orbit || null;
            this.radiusFactor = cfg.radiusFactor || null;
        }

        computeOrbitPosition() {
            if (!this.orbit || !this.orbit.parent) return null;
            const parent = this.game.bodyIndex[this.orbit.parent];
            if (!parent) return null;
            const t = this.game.elapsed || 0;
            const a = (this.orbit.initialAngle ?? 0) + (this.orbit.angularVelocity ?? 0) * t;
            const dist = (this.orbit.distance ?? 0) || parent.worldR * (this.orbit.distanceFactor ?? 5);
            const inc = (this.orbit.inclinationDeg ?? 0) * Math.PI / 180;
            const vflat = this.orbit.verticalFlatten ?? 1;
            const x = parent.worldPos.x + Math.sin(a) * dist;
            const yOrb = Math.cos(a) * dist;
            const y = parent.worldPos.y + yOrb * Math.cos(inc) * vflat;
            const z = parent.worldPos.z;
            return {x, y, z};
        }

        update() {
            const cfg = CONFIG[this.name] || {};
            if (this.keyframes && this.keyframes.length) {
                this.worldPos = interpolateVec3(this.game.elapsed || 0, this.keyframes, {x: 0, y: 0, z: 5});
            } else if (this.orbit && this.orbit.parent) {
                const p = this.computeOrbitPosition();
                if (p) this.worldPos = p;
            }
            if (this.radiusFactor && this.orbit?.parent) {
                const parent = this.game.bodyIndex[this.orbit.parent];
                if (parent) this.worldR = Math.max(0, parent.worldR * this.radiusFactor);
            } else {
                this.worldR = cfg.radius ?? this.worldR;
            }
            if (!this.game.camera.isInFront(this.worldPos)) {
                this.visible = false;
                return
            }
            const proj = this.game.camera.project(this.worldPos);
            this.screen.x = proj.x;
            this.screen.y = proj.y;
            this.screen.r = Math.max(0, this.worldR * proj.k);
            this.visible = this.screen.r > 0;
        }

        draw(ctx) {
            if (!this.visible) return;
            ctx.beginPath();
            ctx.arc(this.screen.x, this.screen.y, this.screen.r, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
        }

        syncToElapsed() {
            this.update()
        }
    }

    class Clouds {
        constructor(game, earthRef) {
            this.game = game;
            this.earthRef = earthRef
        }

        drawLayer(ctx, img, alpha, cyclesPerSec, invert) {
            const earth = this.earthRef;
            if (!img.complete || !earth.visible || earth.screen.r <= 0) return;
            ctx.save();
            ctx.beginPath();
            ctx.arc(earth.screen.x, earth.screen.y, earth.screen.r / 0.98, 0, Math.PI * 2);
            ctx.clip();
            ctx.globalAlpha = alpha;
            const tilt = (CONFIG.earthTiltDeg || 0) * (Math.PI / 180);
            ctx.translate(earth.screen.x, earth.screen.y);
            ctx.rotate(tilt);
            ctx.imageSmoothingEnabled = false;
            ctx.imageSmoothingQuality = "low";
            const diameter = earth.screen.r * 2;
            const scale = diameter / img.naturalHeight;
            const overlayW = img.naturalWidth * scale;
            const overlayH = diameter;
            const xOrigin = -overlayW / 2;
            const yOrigin = -overlayH / 2;
            const cycles = ((this.game.elapsed || 0) * (cyclesPerSec || 0)) % 1;
            const rawOffset = (invert ? -cycles : cycles) * overlayW;
            const offsetPx = ((rawOffset % overlayW) + overlayW) % overlayW;
            const x2 = xOrigin + offsetPx;
            const x1 = x2 - overlayW;
            ctx.drawImage(img, x1, yOrigin, overlayW + 1, overlayH);
            ctx.drawImage(img, x2, yOrigin, overlayW + 1, overlayH);
            ctx.restore();
        }

        draw(ctx, behind = false) {
            const cloudsCfg = CONFIG.earth.clouds || {};
            const invImg = this.game.assetManager.getCloudOverlayInverted();
            const img = this.game.assetManager.getCloudOverlay();
            if (behind) {
                if (invImg.complete) this.drawLayer(ctx, invImg, cloudsCfg.back?.alpha ?? 0.8, cloudsCfg.back?.scrollSpeed ?? 0.015, true);
            } else {
                if (img.complete) this.drawLayer(ctx, img, cloudsCfg.front?.alpha ?? 0.8, cloudsCfg.front?.scrollSpeed ?? 0.03, false);
            }
        }

        update() {
        }

        syncToElapsed() {
            this.update()
        }
    }

    class Moon extends CelestialBody {
        constructor(game) {
            super(game, "moon");
            const cfg = CONFIG.moon || {};
            this.scrollSpeed = cfg.scrollSpeed ?? 0.01;
        }

        drawMoonOverlay(ctx, img, cx, cy, moonSize, cycles) {
            if (!img.complete) return;
            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, moonSize / 2, 0, Math.PI * 2);
            ctx.clip();
            const scale = moonSize / img.naturalHeight;
            const overlayW = img.naturalWidth * scale;
            const overlayH = moonSize;
            const xOrigin = cx - overlayW / 2;
            const yOrigin = cy - overlayH / 2;
            const offsetPx = (cycles % 1) * overlayW;
            ctx.drawImage(img, xOrigin + offsetPx, yOrigin, overlayW, overlayH);
            ctx.drawImage(img, xOrigin + offsetPx - overlayW, yOrigin, overlayW, overlayH);
            ctx.restore();
        }

        draw(ctx, behind = false) {
            if (!this.visible || this.screen.r <= 0) return;
            const angle = (this.orbit?.initialAngle ?? 0) + (this.orbit?.angularVelocity ?? 0) * (this.game.elapsed || 0);
            const depth = Math.cos(angle);
            const isBehind = depth < 0;
            if (behind !== isBehind) return;
            const cycles = ((this.scrollSpeed ?? 0.5) * (this.game.elapsed || 0)) % 1;
            this.drawMoonOverlay(this.game.ctx, this.game.assetManager.getMoonOverlay(), this.screen.x, this.screen.y, this.screen.r * 2, cycles);
            const tilt = (CONFIG.earthTiltDeg || 0) * (Math.PI / 180);
            const baseX = -0.2;
            const baseY = 0.2;
            const offX = baseX * Math.cos(tilt) - baseY * Math.sin(tilt);
            const offY = baseX * Math.sin(tilt) + baseY * Math.cos(tilt);
            applyLighting(this.game.ctx, this.screen.x, this.screen.y, this.screen.r / 0.96, {
                offsetX: offX * 0.5,
                offsetY: offY * 0.5,
                innerColor: behind ? "rgba(255,255,255,0.08)" : "rgba(255,255,255,0.12)",
                outerColor: "rgba(80,80,80,0.08)"
            });
            applySpecularHighlight(this.game.ctx, this.screen.x, this.screen.y, this.screen.r / 0.96, {
                offsetX: offX * 0.4,
                offsetY: offY * 0.4,
                sizeFactor: 0.7,
                color: behind ? "rgba(255,255,255,0.06)" : "rgba(255,255,255,0.1)"
            });
        }
    }

    class Earth extends CelestialBody {
        constructor(game) {
            super(game, "earth");
            this.moon = new Moon(game);
            this.clouds = new Clouds(game, this)
        }

        draw(ctx) {
            if (!this.visible || this.screen.r <= 0) return;
            const earthImg = this.game.assetManager.getEarthSprite();
            if (!earthImg.complete) return;
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            ctx.imageSmoothingQuality = "low";
            ctx.beginPath();
            ctx.arc(this.screen.x, this.screen.y, this.screen.r, 0, Math.PI * 2);
            ctx.clip();
            const tilt = (CONFIG.earthTiltDeg || 0) * (Math.PI / 180);
            ctx.translate(this.screen.x, this.screen.y);
            ctx.rotate(tilt);
            const diameter = this.screen.r * 2;
            const scale = diameter / earthImg.naturalHeight;
            const overlayW = earthImg.naturalWidth * scale;
            const overlayH = diameter;
            const xOrigin = -overlayW / 2;
            const yOrigin = -overlayH / 2;
            const cycles = ((CONFIG.earth.scrollSpeed ?? 0) * (this.game.elapsed || 0)) % 1;
            const offsetPx = (cycles % 1) * overlayW;
            const x1 = xOrigin + offsetPx;
            const x2 = x1 - overlayW;
            ctx.drawImage(earthImg, x1, yOrigin, overlayW, overlayH);
            ctx.drawImage(earthImg, x2, yOrigin, overlayW, overlayH);
            ctx.restore();
            const baseX = -0.2;
            const baseY = 0.2;
            const offX = baseX * Math.cos(tilt) - baseY * Math.sin(tilt);
            const offY = baseX * Math.sin(tilt) + baseY * Math.cos(tilt);
            applyLighting(this.game.ctx, this.screen.x, this.screen.y, this.screen.r / 0.96, {
                offsetX: offX,
                offsetY: offY,
                innerColor: "rgba(255,255,255,0.1)",
                outerColor: "rgba(80,80,80,0.08)"
            });
            applySpecularHighlight(this.game.ctx, this.screen.x, this.screen.y, this.screen.r / 0.96, {
                offsetX: offX,
                offsetY: offY,
                sizeFactor: 0.8,
                color: "rgba(255,255,255,0.2)"
            });
            applyAtmosphere(this.game.ctx, this.screen.x, this.screen.y, this.screen.r / 0.96, {color: "rgba(148,210,255,0.2)"});
        }

        drawChildren(ctx) {
            if (!this.visible || this.screen.r <= 0) return;
            this.moon.draw(ctx, true);
            this.clouds.draw(ctx, true);
            this.draw(ctx);
            this.clouds.draw(ctx, false);
            this.moon.draw(ctx, false);
        }

        syncToElapsed() {
            this.update();
            this.clouds.update();
            this.moon.update();
            this.clouds.syncToElapsed();
            this.moon.syncToElapsed()
        }
    }

    function kfResolveNumeric(t, keyframes, key, def) {
        const kf = (keyframes || []).filter(k => typeof k.second === "number").sort((a, b) => a.second - b.second);
        if (!kf.length) return def;
        let prev = null, next = null;
        for (let i = 0; i < kf.length; i++) {
            if (kf[i].second <= t) prev = kf[i];
            if (kf[i].second >= t) {
                next = kf[i];
                break
            }
        }

        function hasKey(k) {
            return k && Object.prototype.hasOwnProperty.call(k, key) && typeof k[key] === "number"
        }

        if (hasKey(prev) && hasKey(next) && prev !== next) {
            const ease = getEaseFn(prev, next);
            const span = Math.max(1e-6, next.second - prev.second);
            const raw = (t - prev.second) / span;
            const tt = ease(Math.max(0, Math.min(1, raw)));
            return prev[key] + (next[key] - prev[key]) * tt;
        }
        if (hasKey(prev)) return prev[key];
        for (let i = (next ? kf.indexOf(next) : kf.length - 1); i < kf.length; i++) {
            if (hasKey(kf[i])) return kf[i][key]
        }
        for (let i = (prev ? kf.indexOf(prev) : 0); i >= 0; i--) {
            if (hasKey(kf[i])) return kf[i][key]
        }
        return def;
    }

    class StarFields {
        constructor(game, cfg, idx) {
            this.game = game;
            this.cfg = cfg || {
                shape: "circle",
                zRange: [3000, 20000],
                keyframes: [{second: 0, count: 200, size: 1, speed: 1000, focalAngleDeg: 0, focalRadius: 0}]
            };
            const maxCount = Math.max(1, ...((this.cfg.keyframes || []).map(k => Math.max(0, Math.round(k.count ?? 0)))));
            this.POOL_SIZE = Math.max(1024, maxCount * 4);
            this.baseSeed = this.hashStr(`${cfg?.name || "layer"}-${idx}`);
            this.seed = this.baseSeed;
            this.stars = [];
            this.lastT = 0;
            this._p = null;
            this._vp = {x: 0, y: 0};
            const [zMin, zMax] = this.cfg.zRange || [3000, 20000];
            this.zMin = zMin;
            this.zMax = zMax;
            this.depth = Math.max(1, zMax - zMin);
            this.buildPool();
            this.buildSpeedLUT();
        }

        hashStr(s) {
            let h = 2166136261 >>> 0;
            for (let i = 0; i < s.length; i++) {
                h ^= s.charCodeAt(i);
                h = Math.imul(h, 16777619)
            }
            return h >>> 0
        }

        rand() {
            this.seed = (1664525 * this.seed + 1013904223) >>> 0;
            return (this.seed >>> 0) / 4294967296
        }

        randNorm() {
            let u = 0, v = 0;
            while (u === 0) u = this.rand();
            while (v === 0) v = this.rand();
            return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v)
        }

        paramsAt(t) {
            const kf = this.cfg.keyframes || [];
            const count = Math.max(0, Math.round(kfResolveNumeric(t, kf, "count", 200)));
            const size = Math.max(0.1, kfResolveNumeric(t, kf, "size", 1));
            const speed = Math.max(0.1, kfResolveNumeric(t, kf, "speed", 1000));
            const focalAngleDeg = kfResolveNumeric(t, kf, "focalAngleDeg", 0);
            const focalRadius = Math.max(0, Math.min(0.9, kfResolveNumeric(t, kf, "focalRadius", 0)));
            const twinkle = Math.max(0, kfResolveNumeric(t, kf, "twinkle", 0.2));
            const trail = Math.max(0, kfResolveNumeric(t, kf, "trail", 0.1));
            const spread = Math.max(0.1, kfResolveNumeric(t, kf, "spawnSpread", 1.0));
            return {count, size, speed, focalAngleDeg, focalRadius, twinkle, trail, spread};
        }

        vpAt(t) {
            const p = this.paramsAt(t);
            const angle = p.focalAngleDeg * (Math.PI / 180);
            const vpLen = p.focalRadius * 0.9 * this.game.camera.minDim;
            return {vp: {x: Math.cos(angle) * vpLen, y: Math.sin(angle) * vpLen}, p};
        }

        buildPool() {
            this.seed = this.baseSeed;
            this.stars.length = 0;
            for (let i = 0; i < this.POOL_SIZE; i++) {
                const z0 = this.zMin + this.rand() * this.depth;
                const x = this.randNorm();
                const y = this.randNorm();
                const alpha = 0.65 + 0.35 * this.rand();
                const tPhase = this.rand() * Math.PI * 2;
                this.stars.push({x, y, z0, alpha, tPhase});
            }
        }

        speedAt(t) {
            const kf = this.cfg.keyframes || [];
            return Math.max(0.1, kfResolveNumeric(t, kf, "speed", 1000))
        }

        buildSpeedLUT() {
            const dur = Math.max(0.01, CONFIG.journeyDuration || 0);
            this.LUT_DT = 1 / 120;
            const steps = Math.ceil(dur / this.LUT_DT) + 2;
            this.cum = new Float64Array(steps);
            let acc = 0;
            for (let i = 0; i < steps; i++) {
                const t0 = i * this.LUT_DT;
                const t1 = t0 + this.LUT_DT;
                const v0 = this.speedAt(t0);
                const v1 = this.speedAt(t1);
                const area = 0.5 * (v0 + v1) * this.LUT_DT;
                acc += area;
                this.cum[i] = acc;
            }
        }

        travelAt(t) {
            if (t <= 0) return 0;
            const i = Math.min(this.cum.length - 2, Math.floor(t / this.LUT_DT));
            const t0 = i * this.LUT_DT;
            const frac = (t - t0) / this.LUT_DT;
            const c0 = i > 0 ? this.cum[i - 1] : 0;
            const c1 = this.cum[i];
            const c2 = this.cum[i + 1];
            const v0 = c1 - c0;
            const v1 = c2 - c1;
            const inst = v0 + (v1 - v0) * frac;
            return c1 + inst * frac;
        }

        isOnScreen(x, y, W, H, m = 60) {
            return !(x < -m || x > W + m || y < -m || y > H + m)
        }

        starZAtTime(s, t) {
            const d = this.depth;
            let z = this.zMin + (((s.z0 - (this.travelAt(t) % d)) % d) + d) % d;
            if (z < this.zMin + 0.001) {
                const {vp, p} = this.vpAt(t);
                const pr = this.project(s.x, s.y, z, vp, this.game.camera, p.spread, 0.05);
                const W = this.game.canvas.width, H = this.game.canvas.height;
                if (this.isOnScreen(pr.x, pr.y, W, H)) z += d;
            }
            return Math.max(this.zMin + 0.001, Math.min(this.zMax, z));
        }

        project(x, y, z, vp, cam, spread = 1, zClamp = 0.05) {
            const k = (cam.minDim * cam.focal) / Math.max(z, zClamp);
            return {x: cam.cx + vp.x + (x * spread) * k, y: cam.cy + (y * spread) * k + vp.y, k};
        }

        update() {
            const t = this.game.elapsed || 0;
            this.lastT = t;
            const {vp, p} = this.vpAt(t);
            this._vp = vp;
            this._p = p;
        }

        syncToElapsed() {
            this.update()
        }

        draw(ctx) {
            if (!this._p) return;
            const cam = this.game.camera;
            const pNow = this._p;
            const W = this.game.canvas.width, H = this.game.canvas.height;
            const c = Math.max(0, pNow.count || 0);
            const nFull = Math.floor(c);
            const frac = c - nFull;
            const N = Math.min(this.POOL_SIZE, nFull + (frac > 0 ? 1 : 0));
            const tNow = this.game.elapsed || 0;
            const trailDt = pNow.trail > 0 ? pNow.trail * 0.02 : 0;
            const tPast = Math.max(0, tNow - trailDt);
            const {vp: vpPast, p: pPast} = this.vpAt(tPast);
            const deltaTravel = ((this.travelAt(tNow) - this.travelAt(tPast)) % this.depth + this.depth) % this.depth;
            const crossedWrap = deltaTravel > this.depth * 0.5;
            ctx.save();
            ctx.lineCap = "round";
            for (let i = 0; i < N; i++) {
                const s = this.stars[i];
                let alphaMul = 1;
                if (i === nFull && frac > 0) alphaMul = frac;
                const zNow = this.starZAtTime(s, tNow);
                const prNow = this.project(s.x, s.y, zNow, this._vp, cam, pNow.spread, 0.05);
                const sizePx = pNow.size * (0.3 + 15 / Math.sqrt(zNow));
                const trailPad = trailDt > 0 ? Math.max(sizePx, sizePx * 1.5) : 0;
                const MARGIN = 40 + trailPad;
                if (prNow.x < -MARGIN || prNow.x > W + MARGIN || prNow.y < -MARGIN || prNow.y > H + MARGIN) continue;
                let a = s.alpha * alphaMul;
                if (pNow.twinkle > 1e-6) {
                    const tw = 0.5 + 0.5 * Math.sin(tNow * 6 + s.tPhase);
                    a = Math.max(0, Math.min(1, a * (1 - pNow.twinkle * 0.5 + pNow.twinkle * tw * 0.5)));
                }
                ctx.globalAlpha = a;
                if (trailDt > 0 && !crossedWrap) {
                    const zPast = Math.min(this.zMax - 0.001, zNow + deltaTravel);
                    const prPast = this.project(s.x, s.y, zPast, vpPast, cam, pPast.spread, 0.05);
                    ctx.beginPath();
                    ctx.moveTo(prPast.x, prPast.y);
                    ctx.lineTo(prNow.x, prNow.y);
                    ctx.lineWidth = Math.max(1, sizePx * 0.8);
                    ctx.strokeStyle = "#ffffff";
                    ctx.stroke();
                }
                if (this.cfg.shape === "square") {
                    const half = sizePx / 2;
                    ctx.fillStyle = "#ffffff";
                    ctx.fillRect(prNow.x - half, prNow.y - half, sizePx, sizePx);
                } else {
                    ctx.beginPath();
                    ctx.arc(prNow.x, prNow.y, sizePx / 2, 0, Math.PI * 2);
                    ctx.fillStyle = "#ffffff";
                    ctx.fill();
                }
            }
            ctx.restore();
        }
    }

    class AudioPlayer {
        constructor(game) {
            this.game = game;
            this.audio = this.game.assetManager.getSong();
            this.isPlaying = false;
            this._muted = false;
            this._lastVolume = 0.5;
            this.setVolume(0.5);
        }

        play() {
            this.audio.play();
            this.isPlaying = true
        }

        pause() {
            this.audio.pause();
            this.isPlaying = false
        }

        toggle() {
            this.isPlaying ? this.pause() : this.play()
        }

        setVolume(v) {
            const vol = Math.max(0, Math.min(1, v));
            this.audio.volume = vol;
            if (vol > 0) this._lastVolume = vol;
            this._muted = vol === 0;
        }

        setMuted(m) {
            this._muted = !!m;
            if (this._muted) this.audio.volume = 0; else this.audio.volume = this._lastVolume > 0 ? this._lastVolume : 0.25;
        }

        toggleMute() {
            this.setMuted(!this._muted)
        }

        get muted() {
            return this._muted
        }

        get volume() {
            return this.audio.volume || 0
        }

        seekTo(seconds) {
            const a = this.audio;
            const target = Math.max(0, Number(seconds) || 0);
            if (!isNaN(a.duration) && isFinite(a.duration)) a.currentTime = Math.max(0, Math.min(a.duration, target)); else a.currentTime = target;
        }

        getDuration() {
            const d = this.audio.duration;
            return isFinite(d) ? d : 0
        }

        getCurrentTime() {
            return typeof this.audio.currentTime === "number" ? this.audio.currentTime : 0
        }

        addEventListener(type, handler) {
            this.audio.addEventListener(type, handler)
        }
    }

    class UI {
        constructor(game) {
            this.game = game;
            this.canvas = game.canvas;
            this.btn = document.getElementById("music-toggle");
            this.volume = document.getElementById("music-volume");
            this.timeSlider = document.getElementById("timeSlider");
            this.volumeBtn = this.volume ? this.volume.previousElementSibling : null;
            this.timeNowEl = document.getElementById("uiTimeNow");
            this.timeTotalEl = document.getElementById("uiTimeTotal");
            this.fsBtn = document.getElementById("fs-toggle");
            this.bindCanvasClickToggle();
        }

        initControls() {
            this.btn.addEventListener("click", () => {
                this.game.play = !this.game.play;
                if (this.game.play) this.game.audio.play(); else this.game.audio.pause();
                this.updatePlayButton();
            });
            this.volume.addEventListener("input", e => {
                const v = parseFloat(e.target.value);
                this.game.audio.setVolume(v);
                this.renderVolumeIcon();
            });
            if (this.volumeBtn) {
                this.volumeBtn.classList.add("cursor-pointer", "hover:bg-white/20", "transition");
                this.volumeBtn.addEventListener("click", () => {
                    this.game.audio.toggleMute();
                    if (this.game.audio.muted) this.volume.value = "0"; else this.volume.value = String(this.game.audio.volume);
                    this.renderVolumeIcon();
                });
            }
            if (this.timeSlider) {
                this.timeSlider.min = 0;
                this.timeSlider.max = CONFIG.journeyDuration;
                this.timeSlider.step = 0.01;
                this.timeSlider.value = 0;
                const onScrub = sec => {
                    this.game.audio.seekTo(sec);
                    this.game.syncToElapsed()
                };
                this.timeSlider.addEventListener("input", e => onScrub(e.target.value));
                this.timeSlider.addEventListener("change", e => onScrub(e.target.value));
            }
            if (this.fsBtn) {
                this.fsBtn.classList.add("cursor-pointer");
                this.fsBtn.addEventListener("click", async () => {
                    if (!document.fullscreenElement) {
                        const el = document.documentElement;
                        if (el.requestFullscreen) await el.requestFullscreen();
                    } else {
                        if (document.exitFullscreen) await document.exitFullscreen();
                    }
                    this.updateFSButton();
                });
                document.addEventListener("fullscreenchange", () => this.updateFSButton());
                this.updateFSButton();
            }
            this.game.audio.addEventListener("loadedmetadata", () => this.game.syncJourneySecondsFromAudio());
            this.updatePlayButton();
            this.renderVolumeIcon();
            this.setTimeLabel(0, CONFIG.journeyDuration);
        }

        updateFSButton() {
            if (!this.fsBtn) return;
            if (document.fullscreenElement) this.fsBtn.innerHTML = '<svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M9 5H5v4h2V7h2V5zm10 0h-4v2h2v2h2V5zM5 15H3v4h4v-2H5v-2zm16 0h-2v2h-2v2h4v-4z"/></svg>';
            else this.fsBtn.innerHTML = '<svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M7 3H3v4h2V5h2V3zm14 0h-4v2h2v2h2V3zM5 17H3v4h4v-2H5v-2zm16 0h-2v2h-2v2h4v-4z"/></svg>';
        }

        updatePlayButton() {
            if (!this.btn) return;
            if (this.game.play) this.btn.innerHTML = '<svg class="w-4 h-4" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M6 5h4v14H6V5zm8 0h4v14h-4V5z"/></svg>';
            else this.btn.innerHTML = '<svg class="w-4 h-4" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M8 5v14l11-7-11-7z"/></svg>';
        }

        renderVolumeIcon() {
            if (!this.volumeBtn) return;
            const muted = this.game.audio.muted || this.game.audio.volume === 0;
            const v = this.game.audio.volume;
            if (muted) this.volumeBtn.innerHTML = '<svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M5 9v6h4l5 5V4L9 9H5z"/><path d="M19 8l-1.4-1.4L15.8 8.4 14.4 7l-1.4 1.4 1.8 1.8-1.8 1.8L14.4 13l1.4-1.4 1.8 1.8L19 12.9l-1.8-1.8L19 9.3z"/></svg>';
            else if (v <= 0.4) this.volumeBtn.innerHTML = '<svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M5 9v6h4l5 5V4L9 9H5z"/><path d="M17 12c0-1.1-.9-2-2-2v4c1.1 0 2-.9 2-2z"/></svg>';
            else this.volumeBtn.innerHTML = '<svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M5 9v6h4l5 5V4L9 9H5z"/><path d="M16 7v2c1.7 0 3 1.3 3 3s-1.3 3-3 3v2c2.8 0 5-2.2 5-5s-2.2-5-5-5z"/></svg>';
        }

        setSliderValue(v) {
            if (this.timeSlider) this.timeSlider.value = v
        }

        setSliderMax(v) {
            if (this.timeSlider) this.timeSlider.max = v
        }

        setTimeLabel(elapsedSec, totalSec) {
            const fmt = n => {
                const s = Math.max(0, Math.floor(n || 0));
                const m = Math.floor(s / 60);
                const r = s % 60;
                return `${m}:${r < 10 ? "0" + r : r}`;
            };
            if (this.timeNowEl) this.timeNowEl.innerHTML = fmt(elapsedSec);
            if (this.timeTotalEl) this.timeTotalEl.innerHTML = fmt(totalSec);
        }

        bindCanvasClickToggle() {
            this.canvas.addEventListener("click", () => {
                this.game.play = !this.game.play;
                if (this.game.play) this.game.audio.play(); else this.game.audio.pause();
                this.updatePlayButton();
            });
        }
    }

    class SpaceJourneyGame {
        constructor() {
            this.canvas = document.getElementById("viaje");
            this.ctx = this.canvas.getContext("2d");
            this.play = false;
            this.assetManager = new AssetManager();
            this.camera = new Camera(this);
            this.sun = new CelestialBody(this, "sun");
            this.mercury = new CelestialBody(this, "mercury");
            this.venus = new CelestialBody(this, "venus");
            this.mars = new CelestialBody(this, "mars");
            this.jupiter = new CelestialBody(this, "jupiter");
            this.saturn = new CelestialBody(this, "saturn");
            this.uranus = new CelestialBody(this, "uranus");
            this.neptune = new CelestialBody(this, "neptune");
            this.earth = new Earth(this);
            this.audio = new AudioPlayer(this);
            this.ui = new UI(this);
            this.elapsed = 0;
            this.bodyIndex = {};
            this.starLayers = (CONFIG.starFields || []).map((cfg, i) => new StarFields(this, cfg, i));
            autoExtendJourneySeconds();
            this.indexBodies();
            this.resizeCanvas();
            this.bindWindowEvents();
            this.ui.initControls();
            this.animate();
        }

        indexBodies() {
            this.bodyIndex["sun"] = this.sun;
            this.bodyIndex["mercury"] = this.mercury;
            this.bodyIndex["venus"] = this.venus;
            this.bodyIndex["mars"] = this.mars;
            this.bodyIndex["jupiter"] = this.jupiter;
            this.bodyIndex["saturn"] = this.saturn;
            this.bodyIndex["uranus"] = this.uranus;
            this.bodyIndex["neptune"] = this.neptune;
            this.bodyIndex["earth"] = this.earth;
            this.bodyIndex["moon"] = this.earth.moon;
        }

        bindWindowEvents() {
            window.addEventListener("resize", () => this.resizeCanvas())
        }

        syncJourneySecondsFromAudio() {
            const dur = this.audio.getDuration();
            const maxFromConfig = maxSecondInConfig(CONFIG);
            CONFIG.journeySeconds = Math.max(CONFIG.journeySeconds || 0, maxFromConfig, dur);
            this.ui.setSliderMax(CONFIG.journeyDuration);
        }

        syncToElapsed() {
            this.sun.syncToElapsed?.();
            this.mercury.syncToElapsed?.();
            this.venus.syncToElapsed?.();
            this.mars.syncToElapsed?.();
            this.jupiter.syncToElapsed?.();
            this.saturn.syncToElapsed?.();
            this.uranus.syncToElapsed?.();
            this.neptune.syncToElapsed?.();
            this.earth.syncToElapsed?.();
            this.starLayers.forEach(l => l.syncToElapsed());
            this.camera.update();
        }

        resizeCanvas() {
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            const w = Math.floor(window.innerWidth);
            const h = Math.floor(window.innerHeight);
            this.canvas.style.width = w + "px";
            this.canvas.style.height = h + "px";
            this.canvas.width = Math.round(w * dpr);
            this.canvas.height = Math.round(h * dpr);
            this.camera.onResize();
        }

        drawBackground(ctx) {
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }

        update() {
            this.sun.update();
            this.mercury.update();
            this.venus.update();
            this.mars.update();
            this.jupiter.update();
            this.saturn.update();
            this.uranus.update();
            this.neptune.update();
            this.earth.update();
            this.earth.moon.update();
            this.starLayers.forEach(l => l.update());
            this.camera.update();
        }

        draw() {
            this.drawBackground(this.ctx);
            this.starLayers.filter(l => l.cfg.behindBodies !== false).forEach(l => l.draw(this.ctx));
            if (this.earth.visible && this.earth.screen.r > 0) this.earth.drawChildren(this.ctx);
            this.sun.draw(this.ctx);
            this.mercury.draw(this.ctx);
            this.venus.draw(this.ctx);
            this.mars.draw(this.ctx);
            this.jupiter.draw(this.ctx);
            this.saturn.draw(this.ctx);
            this.uranus.draw(this.ctx);
            this.neptune.draw(this.ctx);
            this.starLayers.filter(l => l.cfg.behindBodies === false).forEach(l => l.draw(this.ctx));
        }

        animate() {
            this.elapsed = this.audio.getCurrentTime();
            if (this.play) this.update(); else this.syncToElapsed();
            this.ui.setSliderValue(this.elapsed);
            this.ui.setTimeLabel(this.elapsed, CONFIG.journeyDuration);
            this.draw();
            requestAnimationFrame(() => this.animate());
        }
    }

    document.addEventListener("DOMContentLoaded", () => {
        new SpaceJourneyGame()
    });
</script>
</body>
</html>
